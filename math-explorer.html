<!DOCTYPE html>
<html>
<head>
    <title>Math Explorer - RoboMath</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            font-size: 3em;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #666;
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        #home-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: #f8f9fa;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 0 5px;
        }
        .tab.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .tab-content {
            display: none;
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .tab-content.active {
            display: block;
        }
        .section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }
        .highlight {
            background: #e3f2fd;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            color: #1976d2;
        }
        .formula {
            background: #fff3cd;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid #ffc107;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        .derivation {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #6c757d;
        }
        .intuition {
            background: #d1ecf1;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #0c5460;
        }
        .method-comparison {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }
        .advanced-section {
            background: #fce4ec;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #e91e63;
        }
        h3 {
            color: #333;
            margin-top: 0;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        h4 {
            color: #495057;
            margin-top: 25px;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            color: #666;
            font-size: 0.9em;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 8px 0;
            line-height: 1.5;
        }
        .math-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .math-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .math-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö RoboMath Math Explorer</h1>
            <div class="subtitle">Complete Mathematical Foundations of Robot Kinematics & Dynamics</div>
            <button id="home-btn" onclick="window.location.href='index.html'">üè† Back to Main Menu</button>
        </header>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('beginner')">üéì Beginner</button>
            <button class="tab" onclick="switchTab('advanced')">‚ö° Advanced</button>
        </div>
        
        <!-- BEGINNER TAB CONTENT -->
        <div id="beginner-tab" class="tab-content active">
            <div class="section">
                <h3>üéØ Introduction to Robot Mathematics</h3>
                <p>Welcome to the world of robotic mathematics! This beginner section will help you understand the fundamental concepts that make robots move intelligently.</p>
            </div>

            <div class="section">
                <h3>üßÆ The Core Equation: <span class="highlight">œâ = J‚Åª¬π v</span></h3>
                <p>This is the most important equation in velocity-based robot control. Let's break it down:</p>
                
                <div class="math-grid">
                    <div class="math-card">
                        <h4>ü§î The Problem</h4>
                        <p>We know <strong>where</strong> we want the robot's hand to move (velocity <span class="highlight">v</span>), but we can only control <strong>how fast the joints rotate</strong> (joint velocities <span class="highlight">œâ</span>).</p>
                    </div>
                    <div class="math-card">
                        <h4>üí° The Solution</h4>
                        <p>The Jacobian matrix <span class="highlight">J</span> connects these two spaces. Its inverse <span class="highlight">J‚Åª¬π</span> converts hand velocity to joint velocities.</p>
                    </div>
                </div>

                <div class="formula">
                    <strong>Forward Relationship:</strong> v = J ¬∑ œâ<br>
                    <strong>Inverse Solution:</strong> œâ = J‚Åª¬π ¬∑ v
                </div>
            </div>

            <div class="section">
                <h3>üìê Step-by-Step Mathematics</h3>
                
                <h4>1. Forward Kinematics: Where is the hand?</h4>
                <div class="formula">
                    x = L‚ÇÅ¬∑cos(Œ∏‚ÇÅ) + L‚ÇÇ¬∑cos(Œ∏‚ÇÅ + Œ∏‚ÇÇ)<br>
                    y = L‚ÇÅ¬∑sin(Œ∏‚ÇÅ) + L‚ÇÇ¬∑sin(Œ∏‚ÇÅ + Œ∏‚ÇÇ)
                </div>
                <div class="intuition">
                    <strong>üß† Intuition:</strong> This is like giving someone directions: "Rotate your shoulder by Œ∏‚ÇÅ, then your elbow by Œ∏‚ÇÇ." The equations calculate exactly where the hand ends up.
                </div>

                <h4>2. The Jacobian Matrix: The Magic Translator</h4>
                <div class="formula">
                    J = [ ‚àÇx/‚àÇŒ∏‚ÇÅ  ‚àÇx/‚àÇŒ∏‚ÇÇ ] = [ -L‚ÇÅ¬∑sinŒ∏‚ÇÅ - L‚ÇÇ¬∑sin(Œ∏‚ÇÅ+Œ∏‚ÇÇ)  -L‚ÇÇ¬∑sin(Œ∏‚ÇÅ+Œ∏‚ÇÇ) ]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;[ ‚àÇy/‚àÇŒ∏‚ÇÅ  ‚àÇy/‚àÇŒ∏‚ÇÇ ] &nbsp;&nbsp;&nbsp;[  L‚ÇÅ¬∑cosŒ∏‚ÇÅ + L‚ÇÇ¬∑cos(Œ∏‚ÇÅ+Œ∏‚ÇÇ)   L‚ÇÇ¬∑cos(Œ∏‚ÇÅ+Œ∏‚ÇÇ) ]
                </div>
                <div class="intuition">
                    <strong>üß† Intuition:</strong> Each entry in the Jacobian tells us how sensitive the hand position is to each joint angle. It's like knowing how much the hand moves when you wiggle each joint slightly.
                </div>

                <h4>3. Velocity Transformation</h4>
                <div class="formula">
                    [ dx/dt ] &nbsp;&nbsp; = J ¬∑ [ dŒ∏‚ÇÅ/dt ]<br>
                    [ dy/dt ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ dŒ∏‚ÇÇ/dt ]
                </div>
                <div class="intuition">
                    <strong>üß† Intuition:</strong> This is the chain rule from calculus, but in matrix form! It says "hand velocity equals Jacobian times joint velocities."
                </div>

                <h4>4. The Inverse Solution</h4>
                <div class="formula">
                    œâ = J‚Åª¬π ¬∑ v
                </div>
                <div class="intuition">
                    <strong>üß† Intuition:</strong> We "undo" the transformation to go from desired hand motion to required joint motions. This is like solving a puzzle backwards!
                </div>
            </div>

            <div class="section">
                <h3>üîç Understanding Singularities</h3>
                <p><strong>What are singularities?</strong> Configurations where the robot loses mobility in certain directions.</p>
                
                <div class="math-grid">
                    <div class="math-card">
                        <h4>üìè Fully Stretched</h4>
                        <p>When the arm is completely straight, it can't move radially inward/outward. det(J) ‚âà 0</p>
                    </div>
                    <div class="math-card">
                        <h4>üîÑ Completely Folded</h4>
                        <p>When the arm is completely bent, certain motions become impossible. det(J) ‚âà 0</p>
                    </div>
                </div>
                
                <div class="intuition">
                    <strong>üß† Intuition:</strong> Think of trying to push a car when you're standing right next to it - you can't generate much force in that direction. Similarly, robots have configurations where they can't move in certain directions.
                </div>
            </div>

            <div class="section">
                <h3>üéì Real-World Applications</h3>
                <div class="math-grid">
                    <div class="math-card">
                        <h4>üè≠ Industrial Robots</h4>
                        <p>Assembly lines, welding, painting - all use these same mathematical principles.</p>
                    </div>
                    <div class="math-card">
                        <h4>ü¶æ Medical Robotics</h4>
                        <p>Surgical robots use precise inverse kinematics for delicate operations.</p>
                    </div>
                    <div class="math-card">
                        <h4>üöÄ Space Exploration</h4>
                        <p>Mars rovers and space station arms rely on these equations.</p>
                    </div>
                    <div class="math-card">
                        <h4>üéÆ Animation & Games</h4>
                        <p>Character movement and inverse kinematics create realistic animations.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ADVANCED TAB CONTENT -->
        <div id="advanced-tab" class="tab-content">
            <div class="section">
                <h3>‚ö° Advanced Robotics Mathematics</h3>
                <p>Ready to dive deeper? This section covers the complete mathematical framework for robot dynamics and advanced control techniques.</p>
            </div>

            <div class="advanced-section">
                <h3>üìà Complete Dynamic Equations</h3>
                
                <h4>The Lagrangian Formulation</h4>
                <div class="formula">
                    M(Œ∏)Œ∏Ãà + C(Œ∏,Œ∏Ãá)Œ∏Ãá + G(Œ∏) = œÑ
                </div>
                <div class="intuition">
                    <strong>üß† Historical Context:</strong> Developed by Joseph-Louis Lagrange in 1788, this formulation provides a powerful way to derive equations of motion without dealing with constraint forces directly. It's particularly elegant for complex mechanical systems like robots.
                </div>

                <h4>Breaking Down the Equation</h4>
                
                <div class="math-grid">
                    <div class="math-card">
                        <h4>M(Œ∏)Œ∏Ãà - Inertia Forces</h4>
                        <div class="formula">
                            M(Œ∏) = [ m‚ÇÅ‚ÇÅ  m‚ÇÅ‚ÇÇ ]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ m‚ÇÇ‚ÇÅ  m‚ÇÇ‚ÇÇ ]
                        </div>
                        <p><strong>Physical Meaning:</strong> Relates joint accelerations to torques, accounting for the mass distribution of all links.</p>
                        <p><strong>Properties:</strong> Symmetric, positive definite, configuration-dependent</p>
                    </div>
                    
                    <div class="math-card">
                        <h4>C(Œ∏,Œ∏Ãá)Œ∏Ãá - Coriolis & Centrifugal</h4>
                        <div class="formula">
                            C(Œ∏,Œ∏Ãá) = [ -m‚ÇÇL‚ÇÅr‚ÇÇŒ∏Ãá‚ÇÇsinŒ∏‚ÇÇ  -m‚ÇÇL‚ÇÅr‚ÇÇ(Œ∏Ãá‚ÇÅ+Œ∏Ãá‚ÇÇ)sinŒ∏‚ÇÇ ]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[  m‚ÇÇL‚ÇÅr‚ÇÇŒ∏Ãá‚ÇÅsinŒ∏‚ÇÇ        0                    ]
                        </div>
                        <p><strong>Coriolis Forces:</strong> Appear due to rotating reference frames</p>
                        <p><strong>Centrifugal Forces:</strong> The "flying out" effect of rotation</p>
                    </div>
                    
                    <div class="math-card">
                        <h4>G(Œ∏) - Gravity Forces</h4>
                        <div class="formula">
                            G(Œ∏) = [ (m‚ÇÅgr‚ÇÅ + m‚ÇÇgL‚ÇÅ)cosŒ∏‚ÇÅ + m‚ÇÇgr‚ÇÇcos(Œ∏‚ÇÅ+Œ∏‚ÇÇ) ]<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ m‚ÇÇgr‚ÇÇcos(Œ∏‚ÇÅ+Œ∏‚ÇÇ)                               ]
                        </div>
                        <p><strong>Physical Meaning:</strong> Torques required to counteract gravity</p>
                        <p><strong>Dependencies:</strong> Mass distribution, gravitational field, configuration</p>
                    </div>
                    
                    <div class="math-card">
                        <h4>œÑ - Control Torques</h4>
                        <p><strong>Input:</strong> Torques applied by motors at each joint</p>
                        <p><strong>Output:</strong> The motion we observe</p>
                        <p><strong>Design Goal:</strong> Compute œÑ to achieve desired motion</p>
                    </div>
                </div>

                <h4>Derivation via Lagrangian Mechanics</h4>
                <div class="derivation">
                    <strong>Step 1: Kinetic Energy (T)</strong><br>
                    T = ¬ΩŒ∏Ãá·µÄM(Œ∏)Œ∏Ãá<br>
                    This comes from summing the translational and rotational kinetic energy of each link.
                    
                    <br><br><strong>Step 2: Potential Energy (V)</strong><br>
                    V = m‚ÇÅgh‚ÇÅ + m‚ÇÇgh‚ÇÇ<br>
                    Where h‚ÇÅ, h‚ÇÇ are the heights of each link's center of mass.
                    
                    <br><br><strong>Step 3: Lagrangian (L)</strong><br>
                    L = T - V
                    
                    <br><br><strong>Step 4: Euler-Lagrange Equation</strong><br>
                    d/dt(‚àÇL/‚àÇŒ∏Ãá) - ‚àÇL/‚àÇŒ∏ = œÑ<br>
                    This yields our dynamic equations after extensive vector calculus.
                </div>
            </div>

            <div class="advanced-section">
                <h3>üîÑ Solving the Dynamic Equations</h3>
                
                <h4>Three Solution Approaches</h4>
                
                <div class="math-grid">
                    <div class="math-card">
                        <h4>1. Analytical Solutions</h4>
                        <p><strong>When:</strong> Simple systems with few degrees of freedom</p>
                        <p><strong>Method:</strong> Direct integration of differential equations</p>
                        <p><strong>Advantage:</strong> Exact solution</p>
                        <p><strong>Limitation:</strong> Only possible for simple cases</p>
                    </div>
                    
                    <div class="math-card">
                        <h4>2. Numerical Integration</h4>
                        <p><strong>When:</strong> Most practical applications</p>
                        <p><strong>Methods:</strong> Runge-Kutta, Euler, Verlet integration</p>
                        <p><strong>Advantage:</strong> Handles complex systems</p>
                        <p><strong>Limitation:</strong> Approximation errors, stability issues</p>
                    </div>
                    
                    <div class="math-card">
                        <h4>3. Real-Time Control</h4>
                        <p><strong>When:</strong> Robotics applications</p>
                        <p><strong>Methods:</strong> Computed torque, feedback linearization</p>
                        <p><strong>Advantage:</strong> Handles uncertainties and disturbances</p>
                        <p><strong>Limitation:</strong> Requires good system model</p>
                    </div>
                </div>

                <h4>Computed Torque Control</h4>
                <div class="formula">
                    œÑ = M(Œ∏)(Œ∏Ãà_d + K_v(Œ∏Ãá_d - Œ∏Ãá) + K_p(Œ∏_d - Œ∏)) + C(Œ∏,Œ∏Ãá)Œ∏Ãá + G(Œ∏)
                </div>
                <div class="intuition">
                    <strong>üß† Control Strategy:</strong> Use feedback to cancel out nonlinearities and track desired trajectory. The PD terms (K_p, K_v) provide robustness to modeling errors.
                </div>
            </div>

            <div class="advanced-section">
                <h3>üéØ Advanced Inverse Kinematics Methods</h3>
                
                <h4>Damped Least Squares (Levenberg-Marquardt)</h4>
                <div class="formula">
                    œâ = J·µÄ(JJ·µÄ + Œª¬≤I)‚Åª¬πv
                </div>
                
                <div class="derivation">
                    <strong>Mathematical Derivation:</strong><br>
                    1. <strong>Regularized Objective:</strong> minimize ‚Äñv - Jœâ‚Äñ¬≤ + Œª¬≤‚Äñœâ‚Äñ¬≤<br>
                    2. <strong>Expand:</strong> (v - Jœâ)·µÄ(v - Jœâ) + Œª¬≤œâ·µÄœâ<br>
                    3. <strong>Take Derivative:</strong> -2J·µÄ(v - Jœâ) + 2Œª¬≤œâ = 0<br>
                    4. <strong>Solve:</strong> (J·µÄJ + Œª¬≤I)œâ = J·µÄv<br>
                    5. <strong>Equivalent Form:</strong> œâ = J·µÄ(JJ·µÄ + Œª¬≤I)‚Åª¬πv
                </div>

                <div class="intuition">
                    <strong>üß† Trade-off Interpretation:</strong> The damping factor Œª creates a trade-off:<br>
                    - <strong>Small Œª:</strong> Better accuracy but larger joint velocities near singularities<br>
                    - <strong>Large Œª:</strong> Smaller joint velocities but less accurate tracking<br>
                    This is essentially a <strong>regularization</strong> technique that prevents overfitting to the velocity constraint.
                </div>

                <h4>Comprehensive Method Comparison</h4>
                
                <div class="method-comparison">
                    <h4>1. Jacobian Transpose Method</h4>
                    <div class="formula">œâ = Œ±J·µÄv</div>
                    <p><strong>Advantages:</strong></p>
                    <ul>
                        <li>Extremely simple computation (no matrix inversion)</li>
                        <li>Guaranteed convergence to a solution</li>
                        <li>Numerically stable</li>
                    </ul>
                    <p><strong>Disadvantages:</strong></p>
                    <ul>
                        <li>Slow convergence rate</li>
                        <li>Poor performance near singularities</li>
                        <li>Requires careful tuning of step size Œ±</li>
                    </ul>
                    <p><strong>Use Case:</strong> Simple educational applications, initial prototyping</p>
                </div>

                <div class="method-comparison">
                    <h4>2. Pseudoinverse Method (Moore-Penrose)</h4>
                    <div class="formula">œâ = J‚Å∫v = J·µÄ(JJ·µÄ)‚Åª¬πv</div>
                    <p><strong>Advantages:</strong></p>
                    <ul>
                        <li>Mathematically optimal solution in least-squares sense</li>
                        <li>Minimum norm solution</li>
                        <li>Well-understood theoretical properties</li>
                    </ul>
                    <p><strong>Disadvantages:</strong></p>
                    <ul>
                        <li>Fails catastrophically at singularities</li>
                        <li>Can produce extremely large joint velocities</li>
                        <li>Numerically unstable near singular configurations</li>
                    </ul>
                    <p><strong>Use Case:</strong> Applications where singularities can be avoided</p>
                </div>

                <div class="method-comparison">
                    <h4>3. Damped Least Squares (Levenberg-Marquardt)</h4>
                    <div class="formula">œâ = J·µÄ(JJ·µÄ + Œª¬≤I)‚Åª¬πv</div>
                    <p><strong>Advantages:</strong></p>
                    <ul>
                        <li>Stable and well-behaved near singularities</li>
                        <li>Smooth transition between configurations</li>
                        <li>Robust to numerical errors</li>
                    </ul>
                    <p><strong>Disadvantages:</strong></p>
                    <ul>
                        <li>Suboptimal solution (introduces bias)</li>
                        <li>Requires tuning of damping factor Œª</li>
                        <li>More computationally expensive than transpose method</li>
                    </ul>
                    <p><strong>Use Case:</strong> Industrial robotics, safety-critical applications</p>
                </div>

                <div class="method-comparison">
                    <h4>4. Weighted Damped Least Squares</h4>
                    <div class="formula">œâ = W‚Åª¬πJ·µÄ(JW‚Åª¬πJ·µÄ + Œª¬≤I)‚Åª¬πv</div>
                    <p><strong>Advantages:</strong></p>
                    <ul>
                        <li>Can prioritize certain joints or directions</li>
                        <li>Better performance for specific tasks</li>
                        <li>Can incorporate joint limits</li>
                    </ul>
                    <p><strong>Disadvantages:</strong></p>
                    <ul>
                        <li>More parameters to tune (weight matrix W)</li>
                        <li>Increased complexity</li>
                        <li>Requires domain knowledge</li>
                    </ul>
                    <p><strong>Use Case:</strong> When joint limitations or task priorities matter</p>
                </div>

                <div class="method-comparison">
                    <h4>5. SVD-Based Methods</h4>
                    <div class="formula">J = UŒ£V·µÄ, œâ = VŒ£‚Å∫U·µÄv</div>
                    <p><strong>Advantages:</strong></p>
                    <ul>
                        <li>Mathematical elegance and clarity</li>
                        <li>Explicit control over singular values</li>
                        <li>Can handle rank-deficient cases gracefully</li>
                    </ul>
                    <p><strong>Disadvantages:</strong></p>
                    <ul>
                        <li>Computationally expensive (O(n¬≥) complexity)</li>
                        <li>Complex implementation</li>
                        <li>Overkill for simple applications</li>
                    </ul>
                    <p><strong>Use Case:</strong> Research, high-precision applications, theoretical studies</p>
                </div>

                <h4>Selection Guidelines</h4>
                <div class="intuition">
                    <strong>For Education:</strong> Start with Jacobian Transpose to understand concepts, then move to Pseudoinverse for mathematical clarity.<br>
                    <strong>For Industry:</strong> Damped Least Squares provides the best balance of performance and reliability.<br>
                    <strong>For Research:</strong> SVD-based methods offer maximum control and theoretical insight.<br>
                    <strong>For Real-Time Systems:</strong> Consider computational constraints - Transpose or Damped Least Squares are usually preferred.
                </div>
            </div>

            <div class="advanced-section">
                <h3>üîÆ Future Directions & Research</h3>
                
                <h4>Machine Learning Approaches</h4>
                <p>Recent research explores using neural networks to learn inverse kinematics mappings, potentially avoiding singularities and computational complexity.</p>
                
                <h4>Adaptive Control</h4>
                <p>Systems that can learn and adapt their dynamic models in real-time for improved performance.</p>
                
                <h4>Quantum Computing</h4>
                <p>Potential for solving complex optimization problems in robot motion planning more efficiently.</p>
            </div>
        </div>
        
        <div class="footer">
            <p>¬© 2024 RoboMath Educational Suite | Advanced Robotics Mathematics</p>
            <p>From fundamental concepts to cutting-edge research in robot motion control</p>
        </div>
    </div>

    <script>
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Activate selected tab
            event.currentTarget.classList.add('active');
        }
    </script>
</body>
</html>